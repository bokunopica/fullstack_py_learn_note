# 软件工程-Python

## 一.代码规范

http://google.github.io/styleguide/pyguide.html

python禅道

```python
import this
```



### 命名

- 类
  - 驼峰
- 变量名
  - 下划线

### 语句

- import
  - 次序
    - 先import内置模块
    - 再import第三方模块
    - 最后自己开发项目的模块
    - 用空行分隔
  - import *
    - 尽量不要使用,会导致命名冲突
- 列表推导式
- 条件表达式

## 二.模块化程序设计

### 1/基本思想

- 将一个大的程序按功能拆成一系列小模块
  - 降低程序设计的复杂性
  - 提高模块的可靠性和复用性
  - 缩短产品的开发周期
  - 易于维护和功能扩展

### 2/基本系统划分

web

#### 1.基于水平划分

- 用户管理
- 权限管理
- ...
- 业务功能

#### 2.基于垂直划分

- 应用服务层
- 业务逻辑层
- 数据存储层

#### 3.基于易变与稳定

- 稳定
  - 通用功能1
  - .....
  - 通用功能N
- 易变
  - 业务逻辑1
  - .....
  - 业务逻辑N

#### 4.基于单一职责

- 类或者函数应该只做一件事,并做好这件事
- 单一职责 != 单一功能
- 单一职责:只有一个引起变化的原因

### 3/面向抽象编程

- 在模块化设计的基础上我们可以先设计出各个模块的股价,或者说对各个模块进行抽象,定义它们之间的接口
- 抽象得到的各模块关键函数在后续开发中不应发生改变,这些函数一旦参数列表/名称/返回值等发生变化,可能造成连带性的一系列修改

### 4/错误与异常处理

- 细化具体的异常类型,更有针对地处理
- 减少try/except块中的代码量
- 在关键部分应该检查变量合法性,包括类型和取值范围等,避免"雪球效应"

- ctrl+c 报错
  - KeyboardInterrupt
  - exit(0)

### 5/代码审查

![image-20200423111332359](..\图片\image-20200423111332359.png)

![image-20200423111431314](..\图片\image-20200423111431314.png)

- 相关工具
  - Pylint
  - http://www.pylint.org/

### 6/代码性能优化

![image-20200423113032782](..\图片\image-20200423113032782.png)

![image-20200423113052847](..\图片\image-20200423113052847.png)

- 寻找瓶颈
  - 性能分析
- 性能分析工具
  - python内置的Profile
  - profile.run()

- 算法复杂度排序
  - O(1),O(lg n),O(n lg n),O(n^2),O(n^3),O(n^k),O(k^n),O(n!)
- 几个基本的性能优化点
  - 循环过程中减少计算量,多重循环时将内存的计算提到上一层
  - 字符串拼接用join(),尽量使用内置函数
  - 使用列表解析和生成器表达式

## 三.单元测试

### 1/基本概念

- 简介

![image-20200423115733164](..\图片\image-20200423115733164.png)

- 原则

![image-20200423115902929](..\图片\image-20200423115902929.png)

- 过程

![image-20200423120042954](..\图片\image-20200423120042954.png)

- 质量

![image-20200423120148771](..\图片\image-20200423120148771.png)

![image-20200423120231115](..\图片\image-20200423120231115.png)

- 方法
  - 静态测试
  - 动态测试
  - 黑盒测试
    - 功能测试
    - 不考虑程序内部逻辑结构和内部特性
  - 白盒测试
    - 结构测试
- 测试工具
  - PyUnit
  - xUnit框架
- Mock测试

### 2/测试用例

- 具有代表性和典型性
- 寻求系统设计和功能设计的弱点
- 既有正确输入也有错误和异常输入
- 考虑用户实际的诸多使用场景

- 四个组成部分
  - 测试用例值
  - 期望结果
  - 前缀值
  - 后缀值

- 输入测试用例值等价类划分
  - 有效等价类
  - 无效等价类
- 边界值分析
  - 等价类划分的补充
  - 值来自有效/无效等价类的边界
- 测试用例生成
  - 正面测试用例:有效等价类
  - 负面测试用例:无效等价类
  - 边界值

### 3/白盒测试

- 基于控制流的测试

![image-20200425223306754](..\图片\image-20200425223306754.png)

- 代码覆盖
  - 语句覆盖
    - 每个可执行语句至少被执行一次
  - 判定覆盖
    - 每个判断取真和取假分支至少经历一次
  - 条件覆盖
    - 每个判断中每个条件的可能取值至少满足一次
  - 判定条件覆盖
    - 判断中所有条件的可能取值至少执行一次,且所有判断的可能结果至少执行一次
  - 条件组合覆盖
    - 判断中所有条件的可能取值至少执行一次,并且每个判断本身的结果至少也执行一次
  - 路径覆盖
    - 覆盖程序中的所有可能的执行路径

## 四.软件过程

- 问题定义
  - 问题提出
  - 可行性研究
  - 可行性分析报告
- 需求开发
  - 收集用户需求
  - 理解和建模系统行为
  - 文档化待开发系统行为
  - 检查和确认
  - 生成软件需求规格说明
- 软件设计
  - 体系结构设计
  - 接口设计
  - 组件设计
  - 数据库设计
- 软件构造
  - 编写代码
  - 单元测试
  - 代码审查
  - 集成调试
  - 系统构建
  - 代码优化
- 软件测试

![image-20200428110612136](..\图片\image-20200428110612136.png)

- 软件维护
  - 定义系统需求
  - 访问现有系统
  - 提出系统变更
  - 修改系统

- 软件项目管理

![image-20200428110822477](..\图片\image-20200428110822477.png)

- 软件配置管理

![image-20200428111033788](..\图片\image-20200428111033788.png)

### 1/软件过程模型

![image-20200428111226337](..\图片\image-20200428111226337.png)

- 瀑布模型
  - 模型开发顺序
    - 需求定义与分析
    - 软件设计
    - 软件构造
    - 软件测试
    - 软件运行与维护

- 原型化模型
  - 模型可视化
  - 让需求用户看得懂

- 迭代式开发
  - 增量模型
    - 新发布中逐步增加功能
  - 迭代模型
    - 一开始就提交完整系统,后续发布完善功能
- 可转换模型
  - 形式化藐视
  - 形式化转换

### 2/敏捷开发

- 宣言
  - 个体和交互 胜过 过程和工具
  - 可以工作的软件 胜过 面面俱到的文档
  - 客户合作 胜过 合同谈判
  - 响应变化 胜过 遵循计划
- scrum迭代开发
  - 将软件生命周期分为多个迭代
  - 每个迭代都是一个小的瀑布模型

## 五.团队组织与管理

### 1/开发人员角色

![image-20200429100730069](..\图片\image-20200429100730069.png)

### 2/项目工作分解

![image-20200429110824632](..\图片\image-20200429110824632.png)

## 六.项目开发管理

### 1/Scrum

- sprint
  - 分析
  - 设计
  - 开发
  - 测试
  - 评审

### 2/用户故事

- 故事格式
  - 谁要使用功能
  - 需要执行什么操作
  - 完成操作带来什么好处
- 特性
  - 独立性
    - 故事之间避免存在依赖
  - 可协商
  - 有价值
  - 可估算
    - 开发者可以估算故事规模和开发时间
  - 短小的
    - 一个迭代内
  - 可测试

- 敏捷估算

## 七.需求工程师

### 1/需求定义

- 概念
  - 满足某种书面规定所要具备的能力	
  - 是系统开发,测试,验收,提交的文档依据
- 涵盖
  - 为什么要设计该系统
  - 系统由谁使用
  - 系统要做什么
  - 系统设计哪些信息
  - 对解决方案有何额外限制
  - 如何使用该系统
  - 质量需达到何种程度

## 八.用例建模

### 1/主要元素

- 用例
  - 定义系统的一系列行为
  - 通过此可为参与者提供有价值且可观测的结果
- 参与者
  - 角色
- 交互
  - 发起方
  - 接收方
  - 参与者与用例之间的交互通道

### 2/建模步骤

- 1.找到所有的参与者与用例
  - 识别出参与者并作简单的描述
    - 谁/什么使用系统
    - 谁/什么从系统中获取信息
    - 谁/什么向系统提供信息
    - 公司的哪个部门使用系统
    - 谁/什么负责系统维护
    - 其他那些系统会使用系统
  - 识别出用例并作简单的介绍
    - 每个参与者的目标
      - 为什么要使用
      - 是否有CRUD操作,为什么
      - 是否需要将改变告诉系统
      - 参与者是否需要知道系统内部发生的事件或改变?
    - 系统是否能够应对业务中所有的正确行为与操作
- 2.编写用例
  - 用例命名
    - 表明参与者的目标或者作用
    - 用动词起始:主动语态
  - 给用例事件流程划分重要等级
  - 按照重要程度排序详细描述事件流程

## 九.